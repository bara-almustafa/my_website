---
description: >-
  A concise, platform-agnostic methodology aligned to OWASP MASVS and MASTG,
  with Android/iOS notes and a drop‑in checklist
cover: ../.gitbook/assets/Mobile-Penetration-Testing.png
coverY: 0
---

# mobile penetration testing methodology

### 1) Pre‑engagement and Scope <a href="#id-1-preengagement-and-scope" id="id-1-preengagement-and-scope"></a>

* Define scope: Android/iOS apps, versions/builds, backend APIs, third‑party SDKs, authentication providers, and test data; clarify black/grey/white‑box access and device types (emulator, rooted/jailbroken, physical).
* Obtain artifacts: APK/IPA, test accounts, API specs, release notes, feature flags, and any required bypass consents; ensure written authorization and anti‑DoS constraints.
* Choose standards: Map testing to OWASP MASVS levels (L1 baseline, L2 defense‑in‑depth, R resiliency) and execute tests via OWASP MASTG cases.

### 2) Discovery and Threat Modeling <a href="#id-2-discovery-and-threat-modeling" id="id-2-discovery-and-threat-modeling"></a>

* Understand app architecture, workflows, data flows, trust boundaries, and sensitive operations (payments, PII, crypto wallets).
* OSINT: app store listings, docs, developer forums, public repos/issues, and exposed endpoints/domains to enrich attack surface mapping.
* Document threats: abuse cases for auth/session, storage, crypto, network, platform interaction, code quality, and anti‑tamper/reverse‑engineering.

### 3) Static Analysis (SAST) <a href="#id-3-static-analysis-sast" id="id-3-static-analysis-sast"></a>

* Unpack and review binaries/resources for hardcoded secrets, API keys, endpoints, debug flags, certificate pins, and insecure configurations.
* Source review (if available): verify MASVS controls for crypto use, input handling, secure storage, and secret management; rely on MASTG test cases for coverage.
* Tools and focus: strings/Smali review, manifest/Info.plist, libraries/SDKs, certificate pinning config, ProGuard/obfuscation status.

### 4) Dynamic Analysis (DAST) <a href="#id-4-dynamic-analysis-dast" id="id-4-dynamic-analysis-dast"></a>

* Intercept traffic with a proxy to assess TLS, pinning, auth/session handling, rate limiting, and API authorization; validate no sensitive data in transit.
* Runtime instrumentation and hooking (e.g., Frida) to probe logic, bypass weak client‑side checks, and assess IPC/Intents/URL schemes for abuse paths.
* Business logic testing: workflow breaks, IDOR, privilege escalation, and server‑side authorization gaps across API endpoints.

### 5) Authentication, Session, and Access Control <a href="#id-5-authentication-session-and-access-control" id="id-5-authentication-session-and-access-control"></a>

* Evaluate login, MFA, step‑up flows, token issuance/refresh, logout/invalidation, and device binding; confirm secure token storage and renewal policies.
* Attempt common abuses: brute/spray with controls, session fixation/hijacking, re‑use of tokens, and weak reset/activation paths.

### 6) Data Storage and Privacy <a href="#id-6-data-storage-and-privacy" id="id-6-data-storage-and-privacy"></a>

* Verify sensitive data is not stored in plaintext in files, logs, caches, backups, notifications, screenshots, or inter‑app shared storage; use secure OS keystores.
* Check clipboard use, analytics/telemetry leakage, and adherence to least‑privilege permissions with justification and runtime prompts.

### 7) Cryptography <a href="#id-7-cryptography" id="id-7-cryptography"></a>

* Validate approved algorithms/modes, proper key sizes, secure randomness, and key lifecycle; ensure no custom crypto or hardcoded keys/seeds.
* Confirm integrity protections for critical data and tokens at rest and in transit.

### 8) Network and API Communication <a href="#id-8-network-and-api-communication" id="id-8-network-and-api-communication"></a>

* Enforce TLS with strong configuration, certificate validation, and pinning where appropriate; confirm secure error handling and no sensitive data in URLs.
* Test server‑side controls: authentication, authorization, rate limiting, input validation, and deserialization safeguards across APIs used by the app.

### 9) Platform Interaction and Hardening <a href="#id-9-platform-interaction-and-hardening" id="id-9-platform-interaction-and-hardening"></a>

* Android: review manifest for exported components, dangerous permissions, WebView settings, Backup/Debuggable flags, and intent filters/IPC security.
* iOS: validate Keychain classes, ATS, entitlements, URL schemes, pasteboard use, and jailbreak detection logic; ensure secure configuration in Info.plist.

### 10) Reverse Engineering Resiliency (By Agreement) <a href="#id-10-reverse-engineering-resiliency-by-agreement" id="id-10-reverse-engineering-resiliency-by-agreement"></a>

* Assess obfuscation, anti‑tamper, root/jailbreak detection, debugger detection, and runtime protections; evaluate resilience against static/dynamic analysis.
* Verify protections don’t break functionality but raise attacker cost; map to MASVS‑R where in scope.

### 11) Exploitation, Risk Demonstration, and Safety <a href="#id-11-exploitation-risk-demonstration-and-safety" id="id-11-exploitation-risk-demonstration-and-safety"></a>

* Safely demonstrate impact of validated issues: data exfiltration from device storage, token theft/misuse, unauthorized API actions, or account takeover paths.
* Respect legal and availability constraints; avoid destructive tests and ensure minimal data exposure in PoCs.

### 12) Reporting and Remediation <a href="#id-12-reporting-and-remediation" id="id-12-reporting-and-remediation"></a>

* Provide executive summary, scope, methodology (MASVS/MASTG mapping), reproducible findings with evidence, risk ratings, and prioritized fixes.
* Include developer‑oriented guidance tied to MASVS requirements and MASTG test case references for retest readiness.

### 13) Retesting and Continuous Assurance <a href="#id-13-retesting-and-continuous-assurance" id="id-13-retesting-and-continuous-assurance"></a>

* Verify fixes, update evidence, and align with a cadence (per release or quarterly); recommend integrating MASVS into SDLC and CI/CD with automated checks where feasible.

***

### Lightweight Mobile App Pentest Checklist (Drop‑in) <a href="#lightweight-mobile-app-pentest-checklist-dropin" id="lightweight-mobile-app-pentest-checklist-dropin"></a>

* Pre‑engagement: scope, artifacts (APK/IPA), accounts, MASVS level mapping.
* Discovery: architecture, endpoints, OSINT, threat model.
* Static: secrets, configs, crypto, manifest/Info.plist, obfuscation status.
* Dynamic: TLS/pinning, auth/session, API authZ, instrumentation tests.
* Storage/privacy: secure keystore use, no plaintext, permissions minimality.
* Crypto: approved primitives, key mgmt, no hardcoded secrets.
* Platform: Android components/WebView; iOS ATS/Keychain/entitlements.
* Resiliency: anti‑tamper/RE defenses per MASVS‑R (if in scope).
* Reporting: MASVS/MASTG mapped findings, prioritized remediation.
* Retest: verify fixes, propose SDLC integration with MASVS checks.

***

### Standards and References: <a href="#standards-and-references-to-anchor-your-gitbook-se" id="standards-and-references-to-anchor-your-gitbook-se"></a>

* OWASP MASVS: baseline, defense‑in‑depth, and resiliency requirements; use it as the control catalog and to map findings/remediation.
* OWASP MASTG: hands‑on test cases and workflows for Android/iOS covering static, dynamic, and reverse engineering procedures.
* Practitioner methodologies and checklists for concrete steps and tool focus across Android/iOS testing
